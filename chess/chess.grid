Item King
{
  int rule(coordinate source, coordinate destination)
  {
    Item src;
    Item dest;
  	int xdiff = abs(destination.x - source.x);
    int ydiff = abs(destination.y - source.y);
    if (xdiff > 1 || ydiff > 1)
    {
      return 0;
    }
    src = Grid<source>.item;
    dest = Grid<destination>.item;
    if (dest!=None)
    {
      dest_color = dest.getProperty("color");
      src_color = src.getProperty("color");
      if(dest_color == src_color)
      {
        return 0;
      }
    }
    int curIndex = getCurrentPlayerIndex();
    int opposingIndex = curIndex + 1 % len(playerList); //How do we get length of playerList?
    Player player = playerList[opposingIndex];
    if (player.king.rule(player.king.location, destination) || player.rook.rule(player.rook.location, destination) ||
        player.bishop.rule(player.bishop.location, destination) || player.knight.rule(player.knight.location, destination) 
        || player.pawn.rule(player.pawn.locaiton, destination))
    {
      return 0;
    }
    return 1;
  }
}

Item Knight
{
   int rule(coordinate source, coordinate destination)
  {
    Item dest;
    Item src;
    int xdiff = abs(destination.x - source.x);
    int ydiff = abs(destination.y - source.y);
    if(xdiff == 2 && ydiff == 1 || xdiff == 1 && ydiff == 2) 
    {
      src = Grid<source>.item;
      dest = Grid<destination>.item;
      if (dest!= None)
      {
        dest_color = dest.getProperty("color");      /*Gets the actual Player/Item that is filled in*/
        src_color = src.getProperty("color");
        if(dest_color == src_color)
        {
          return 0;
        }
      }
      return 1;
    }
    return 0;
  } 
}

Item Rook
{
  int rule(coordinate source, coordinate destination)
  {
    Item dest;
    Item src;
    if(destination.x == source.x || destination.y == source.y)  /* moves either vertically or horizontally */
    {
      src = Grid<source>.item;
      dest = Grid<destination>.item;
      if (dest != None)
      {
        dest_color = dest.getProperty("color");
        src_color = src.getProperty("color");
        if(dest_color == src_color) /* moving to a block with some item of same color, which is not allowed */
        {
          return 0;
        }
      }
      return 1;
    }
    return 0;

  }
}

Item Bishop
{
  int rule(coordinate source, coordinate destination)
  {
    Item dest;
    Item src;
    if(abs(destination.x - source.x) == abs(destination.y - source.y))  /* moves diagonally only*/
    {
      src = Grid<source>.item;
      dest = Grid<destination>.item;
      if (dest != None)
      {
        dest_color = dest.getProperty("color");
        src_color = src.getProperty("color");
        if(dest_color == src_color)  /* moving to a block with some item of same color, which is not allowed */
        {
          return 0;
        }
      }
      return 1;
    }
    return 0;
  }
}

Item Pawn
{
  int rule(coordinate source, coordinate destination)
  {
    int direction;
    Item dest;
    Item src;
    direction = getDirectionFromIndex();
    if(destination.x != source.x + direction)  /* check if pawn moves >1 step vertically, or in the wrong direction*/ 
    {
      return 0;
    }
    if (destination.y - source.y > 1 || destination.y - source.y < -1) /* check if pawn moves more than one square horizontally*/
    {
      return 0;
    }    
    if(destination.y == source.y - 1 || destination.y == source.y + 1) /* if pawn moves diagonally left 1 or right 1, check if item on destination square is the same color */
    {
      src = Grid<source>.item;
      dest = Grid<destination>.item;
      if (dest != None)
      {
        /*Still a little unclear as to how this color property will get filled*/
        dest_color = dest.getProperty("color");      /*Gets the actual Player/Item that is filled in*/
        src_color = src.getProperty("color");
        if(dest_color == src_color)
        {
          return 0;
        }
      }
    }
    return 1;
  } 
}

Player player
{
  Item King king;
  Item Knight knight;
  Item Rook rook;
  Item Bishop bishop;
  Item Pawn pawn;
}

int getDirectionFromIndex()
{
  index = playerOrder.index; /*White=0;Black=1*/
  if(index == 0)
  {
    direction = -1;
  }
  else
  {
    direction = 1;
  }
  return direction;
}

int initialSetup()
{
  Player player white;
  white.color = "white";
  Player player black;
  black.color = "black";
  Grid_Init<5,4>;
  Grid<0,0> = black.king
  Grid<0,1> = black.knight
  Grid<0,2> = black.bishop
  Grid<0,3> = black.rook
  Grid<1,0> = black.pawn
  Grid<4,3> = white.king
  Grid<4,2> = white.knight
  Grid<4,1> = white.bishop
  Grid<4,0> = white.rook
  Grid<3,3> = white.pawn
  playerOrder = [white,black];
  white.displayString = prompt("Enter name for White Player: ");
  black.displayString = prompt("Enter name for Black Player: ");

  return 0;
}

int checkGameEnd()
{
  return 1;
}

int gameloop()
{
  printGrid(); /* shouldn't it be printGrid(4,5,Grid)? */
  coordinate c1;
  coordinate c2;
  print(currentPlayer.displayString);
  c1 = prompt("Enter start coordinate: ");
  Item i = Grid<c1>.item;
  /* check if there's any item at c1? Do we need to? */
  c2 = prompt("Enter end coordinate: ");
  Grid<c2> = i; /*Triggers the rule for i, adds the item i to cell c2, and also triggers any coLocations() if rule succeeds*/
}
