Item King
{
  int rule(coordinate source, coordinate destination)
  {

  }
}

Item Knight
{
   int rule(coordinate source, coordinate destination)
  {
  
  } 
}

Item Rook
{
   int rule(coordinate source, coordinate destination)
  {
  
  } 
}

Item Bishop
{
   int rule(coordinate source, coordinate destination)
  {
  
  } 
}

Item Pawn
{
  int rule(coordinate source, coordinate destination)
  {
    int direction;
    Item i;
    string owner;
    direction = getDirectionFromIndex();
    if(destination.y != source.y + direction) 
    {
      return 0;
    }
    else if(destination.x == source.x - 1 || destination.x == source.x + 1)
    {
      i = Grid<destination>.item;
      item_color = i.owner; /*Gets the actual Player/Item that is filled in*/
      if(item_color == )
      {
        return 0;
      }
      return 1;
    }
    return 0;
  } 
}

Player player
{
  Item King king;
  Item Knight knight;
  Item Rook rook;
  Item Bishop bishop;
  Item Pawn pawn;

}

int getDirectionFromIndex()
{
  index = playerOrder.index; /*White=0;Black=1*/
  if(index == 0)
  {
    direction = -1;
  }
  else
  {
    direction = 1;
  }
  return direction;
}

int initialSetup()
{
  Player player white;
  white.color = "white";
  Player player black;
  black.color = "black";
  Grid_Init<5,4>;
  Grid<0,0> = black.king
  Grid<0,1> = black.knight
  Grid<0,2> = black.bishop
  Grid<0,3> = black.rook
  Grid<1,0> = black.pawn
  Grid<4,3> = white.king
  Grid<4,2> = white.knight
  Grid<4,1> = white.bishop
  Grid<4,0> = white.rook
  Grid<3,3> = white.pawn
  playerOrder = [white,black];
  white.displayString = prompt("Enter name for White Player: ");
  black.displayString = prompt("Enter name for Black Player: ");

  return 0;
}

int checkGameEnd()
{
  return 1;
}

int gameloop()
{
  printGrid();
  coordinate c1;
  coordinate c2;
  print(currentPlayer.displayString);
  c1 = prompt("Enter start coordinate: ");
  Item i = Grid<c1>.item;
  c2 = prompt("Enter end coordinate: ");
  Grid<c2> = i; /*Triggers the rule for i, adds the item i to cell c2, and also triggers any coLocations() if rule succeeds*/
}